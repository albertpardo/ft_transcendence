input {
  http {
    port => 5044
    codec => json
  }

  file {
    path => "/shared_logs/game_service.log"
    start_position => "beginning"
    codec => json
    tags => ["file"]
  }
}

filter {
  if "_jsonparsefailure" in [tags] {
    json {
      source => "message"
      remove_field => ["message"]
    }
  }

  if "favicon.ico" in [message] {
    drop { }
  }

  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  if ![level] {
    mutate { add_field => { "level" => "info" } }
  }

  mutate {
    lowercase => ["level"]
  }
  
  # Arreglar URL
  if [url] {
    ruby {
      code => '
        event.set("[http][url_info]", event.get("url")) if event.get("url").is_a?(Hash)
        event.remove("url")
      '
    }
  }

  # ValidaciÃ³n segura del campo "log.source"
  if [source] and [source] =~ /^\w+([-._]\w+)*$/ {
    mutate {
      add_field => { "[event][dataset]" => "%{[source]}" }
    }
  } else {
    mutate {
      add_field => { "[event][dataset]" => "unknown_source" }
    }
  }
}

output {
  if "file" in [tags] {
    elasticsearch {
      hosts => ["${ELASTIC_URL}"]
      user => "${ELASTIC_US}"
      password => "${ELASTIC_PASSWORD}"
      ssl_enabled => true
      ssl_verification_mode => "full"
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca/ca.crt"]
      ilm_enabled => true
      ilm_policy => "pongfile_policy"
      ilm_rollover_alias => "pongfile"
      ilm_pattern => "000001"
      manage_template => false
    }
  } else {
    elasticsearch {
      hosts => ["${ELASTIC_URL}"]
      user => "${ELASTIC_US}"
      password => "${ELASTIC_PASSWORD}"
      ssl_enabled => true
      ssl_verification_mode => "full"
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca/ca.crt"]
      ilm_enabled => true
      ilm_policy => "ponghttp_policy"
      ilm_rollover_alias => "ponghttp"
      ilm_pattern => "000001"
      manage_template => false
    }
  }

  stdout {
    codec => rubydebug
  }
}
